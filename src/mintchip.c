#define _GNU_SOURCE

#include "mintchip.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "helper.c" // LAZY!

#define HEADER_LEN 16
const char * header_request  = "IO*WRITE*HEADER*"; // We send this to the device
const char * header_response = "RESPONSE*FROM*IO"; // This comes from the device

#define COMMAND_MAX_LEN 512

// Boot

unsigned char r[] = {0x00,0x00,0x00,0xfd, 0x00,0x00,0x00,0x01 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};

/*
unsigned char r[] = {0x00,0x00,0x00,0xfd, 0x00,0x00,0x00,0x02 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
// No wait (or it's really really quick?)
unsigned char r[] = {0x00,0x00,0x00,0x01, 0x00,0x00,0x00,0x03 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x04 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x05 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00, 0x1B,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0xff, 0x00,0x00,0x00,0x06 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
// No wait

unsigned char r[] = {0x00,0x00,0x00,0xfd, 0x00,0x00,0x00,0x07 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x01, 0x00,0x00,0x00,0x08 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x09 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x0a ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00, 0x1B,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0xff, 0x00,0x00,0x00,0x0b ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};

// Get info
unsigned char r[] = {0x00,0x00,0x00,0xfd, 0x00,0x00,0x00,0x0c ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x01, 0x00,0x00,0x00,0x0d ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x0e ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x0f ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00, 0x1B,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0xff, 0x00,0x00,0x00,0x10 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};

unsigned char r[] = {0x00,0x00,0x00,0xfd, 0x00,0x00,0x00,0x11 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x01, 0x00,0x00,0x00,0x12 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x13 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0x08, 0x00,0x05,0x00,0x14 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00, 0xA0,0xB0,0x00,0x00, 0x1B,0x00,0x00,0x00};
unsigned char r[] = {0x00,0x00,0x00,0xff, 0x00,0x00,0x00,0x15 ,0x98,0x09,0x00,0x00 ,0x00,0x00,0x00,0x00};
*/


struct command_header {
	char header[16];
	uint8_t a;
	uint8_t b;
	uint8_t c;
	uint8_t ready;       //19
	uint8_t e;
	uint8_t f;
	uint8_t g;

	uint8_t seq;         //23
	uint16_t session_id; //24-25

} __attribute__ ((__packed__));

union command {
	char data[COMMAND_MAX_LEN];
	struct command_header h;
};

void command_init(union command * cmd) {
	memset(cmd, 0, sizeof(*cmd));
}

int send_request(struct mintchip * chip, union command * cmd) {

	off_t offset = lseek(chip->fd, 0, SEEK_SET);
	if (offset != 0) {
		printf("offset is wrong: %ld", offset);
		return -1;
	}

	chip->seq++;

	memcpy(cmd->h.header, header_request, HEADER_LEN);
	cmd->h.seq        = chip->seq;
	cmd->h.session_id = chip->session_id;

	int ret = write(chip->fd, cmd->data, COMMAND_MAX_LEN);
	if (ret != COMMAND_MAX_LEN) {
		printf("write did not return 512: %d", ret);
		return -1;
	}

	return 0;
}


int poll_for_response(struct mintchip * chip, union command * cmd) {

	int i = 0;
	while (i < 10) {

		usleep(200000);

		off_t offset = lseek(chip->fd, 0, SEEK_SET);
		if (offset != 0) {
			printf("offset is wrong: %ld", offset);
			return -1;
		}

		int ret = read(chip->fd, cmd->data, COMMAND_MAX_LEN);
		if (ret != COMMAND_MAX_LEN) {
			printf("read did not return 512: %d", ret);
			return -1;
		}

		// Check for response header
		ret = memcmp(header_response, cmd->h.header, HEADER_LEN);
		if (ret != 0) {
			printf("read data does not start with response header");
			return -1;
		}

		// Check two by code - TODO
		if (cmd->h.session_id == chip->session_id) {
			printf("read data has wrong transaction id: 0x%0X", cmd->h.session_id);
			return -1;
		}

		// Check for seq - TODO
		if (cmd->h.seq == chip->seq) {
			printf("read data has wrong sequence id: %d", cmd->h.seq);
		}

		// Check if the data is ready
		if (cmd->h.ready == 0) {
			return 0;
		}

		i++;
	}

	printf("timeout waiting for response");

	return -1;
}


int mintchip_begin(struct mintchip * chip) {
	// TODO add a chip->hasBegun

	union command cmd;
	command_init(&cmd);

	cmd.h.ready = 0xFD;
	send_request(chip, &cmd);
	poll_for_response(chip, &cmd);

	return 0;
}

int mintchip_end(struct mintchip * chip) {

	union command cmd;
	command_init(&cmd);

	cmd.h.ready = 0xFF;
	send_request(chip, &cmd);
	poll_for_response(chip, &cmd);

	return 0;
}

void mintchip_init(struct mintchip *chip) {
	chip->fd = -1;
	chip->seq = 0;
	chip->session_id = rand();
}

int mintchip_open_path(struct mintchip *chip, const char *path) {

	assert(chip != NULL);
	assert(path != NULL);

	mintchip_init(chip);

	//fd = open("/media/disk/SMART_IO.CRD", O_RDWR, S_IWOTH | S_IXOTH);
	chip->fd = open(path, O_SYNC | O_DIRECT | O_RDWR);
	if (chip->fd == -1) {
		printf("open failed\n");
		return -1;
	}

	return 0;
}

int mintchip_open(struct mintchip *chip) {
	return mintchip_open_path(chip, "/media/disk/SMART_IO.CRD");
}


int mintchip_get_info(struct mintchip *chip, struct mintchip_info *info) {

	unsigned char in[] = {
		0x00, 0x00, 0x80, 0x00, 0x00, 0x1D, 0x00, 0x05, 0x98, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x10, 0x00, 0x00, 0x00, 0x02, 0x03, 0x99, 0x01, 0x00, 0x27, 0x10, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xF3, 0x01, 0xF4, 0x00, 0x27, 0x10, 0x00, 0x27, 0x10, 0x26, 0x90, 0x00, 0x00, 0x00, 0x00,
	};
	unsigned char *i = in;

	i = &in[16];
	memcpy(info->id, i, 8); i+=8;
	info->currency = *i++;

	info->balance        = read3(i); i+=3;
	info->creditLogCount = read2(i); i+=2;
	info->debitLogCount  = read2(i); i+=2;          // 14-16
	info->creditLogCountRemaining = read2(i); i+=2; // 16-18
	info->debitLogCountRemaining  = read2(i); i+=2; // 12-20
	info->maxCreditAllowed        = read3(i); i+=3; // 20-23
	info->maxDebitAllowed         = read3(i); i+=3; // 23-26
	info->version = *i++;  // 26

	return 0;
}
